/*
 * Copyright (C) 2016 - OpenSIPS Foundation
 * Copyright (C) 2001-2003 FhG Fokus
 *
 * This file is part of opensips, a free SIP server.
 *
 * opensips is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version
 *
 * opensips is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * History:
 * -------
 *  2016-09-19  first version (Ionut Ionita)
 */
#ifndef _mi_trace_h
#define _mi_trace_h

#include "../trace_api.h"

extern trace_proto_t* mi_trace_api;
extern int correlation_id, correlation_vendor;
extern str correlation_value;

void try_load_trace_api(void);
int trace_mi_message(union sockaddr_union* src, union sockaddr_union* dst,
		str* body, str* correlation_value, trace_dest trace_dst);
char* build_mi_trace_request( str* cmd, struct mi_root* mi_req, str* backend);
char* build_mi_trace_reply( int code, str* reason, str* rpl_msg );
char* generate_correlation_id(int* len);
int load_correlation_id(void);

static inline void mi_trace_reply( union sockaddr_union* src, union sockaddr_union* dst,
		int code, str* reason, str* message, trace_dest t_dst)
{
	str trace_buf;

	/* trace disabled */
	if ( !t_dst )
		return;

	/* message can be null */
	if ( !reason ) {
		LM_ERR("traced reply needs to have a reason!\n");
		return;
	}

	trace_buf.s = build_mi_trace_reply( code, reason, message);
	if ( !trace_buf.s ) {
		LM_ERR("can't build reply buffer!\n");
		return;
	}

	trace_buf.len = strlen(trace_buf.s);
	if ( !correlation_value.s ) {
		LM_ERR("can't find correlation id generated by the request!\n");
		return;
	}

	if (trace_mi_message( src, dst, &trace_buf, &correlation_value, t_dst) < 0) {
		LM_ERR("failed to trace mi command reply!\n");
	}
}


static inline void mi_trace_request( union sockaddr_union* src, union sockaddr_union* dst,
		char* command, int len, struct mi_root* mi_req, str* backend, trace_dest t_dst )
{
	str comm_s = { command, len };
	str trace_buf;

	if ( !t_dst || !backend )
		return;

	trace_buf.s = build_mi_trace_request( &comm_s, mi_req, backend);
	if ( !trace_buf.s ) {
		LM_ERR("Can't build mi request for tracing!\n");
		return;
	}

	trace_buf.len = strlen(trace_buf.s);
	correlation_value.s = generate_correlation_id(&correlation_value.len);

	if ( !correlation_value.s ) {
		LM_ERR("failed to generate correlation id!\n");
		return;
	}

	if (trace_mi_message( src, dst, &trace_buf, &correlation_value, t_dst) < 0) {
		LM_ERR("failed to trace mi command request!\n");
	}
}

int register_mi_trace_mod(void);
int init_mod_trace_cmds(int id, int white);

int block_mi_cmd_trace(int id, char* name, int len);
int allow_mi_cmd_trace(int id, char* name, int len);
unsigned char is_mi_cmd_traced(int id, struct mi_cmd* cmd);
int parse_mi_cmd_bwlist(int id, char* bw_string, int len);



#endif
